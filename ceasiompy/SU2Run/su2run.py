"""
CEASIOMpy: Conceptual Aircraft Design Software

Developed by CFS ENGINEERING, 1015 Lausanne, Switzerland

Module to run SU2 Calculation in CEASIOMpy

Python version: >=3.6

| Author : Aidan Jungo
| Creation: 2018-11-06
| Last modifiction: 2020-05-20

TODO:

    * Add possibility of using SSH
    * Create test functions
    * complete input/output in __specs__
    * Check platform with-> sys.platform
    * Move run_SU2_fsi to /SU2Run/func/su2fsi.py

"""

#==============================================================================
#   IMPORTS
#==============================================================================

import os
import sys
import shutil
import datetime

import ceasiompy.utils.ceasiompyfunctions as ceaf
import ceasiompy.utils.cpacsfunctions as cpsf
import ceasiompy.utils.apmfunctions as apmf
import ceasiompy.utils.su2functions as su2f

from ceasiompy.SU2Run.func.su2config import generate_su2_config
from ceasiompy.SU2Run.func.extractloads import extract_loads
from ceasiompy.SU2Run.func.su2results import get_wetted_area, get_efficiency, get_su2_results

from ceasiompy.utils.ceasiomlogger import get_logger
log = get_logger(__file__.split('.')[0])

MODULE_DIR = os.path.dirname(os.path.abspath(__file__))
SU2_XPATH = '/cpacs/toolspecific/CEASIOMpy/aerodynamics/su2'

#==============================================================================
#   CLASSES
#==============================================================================


#==============================================================================
#   FUNCTIONS
#==============================================================================

def run_SU2_single(config_path, wkdir, nb_proc):
    """Function to run a single SU2 claculation.

    Function 'run_SU2_single' will run in the given working directory a SU2
    calculation (SU2_CFD then SU2_SOL) with the given config_path.

    Args:
        config_path (str): Path to the configuration file
        wkdir (str): Path to the working directory

    """

    if not os.path.exists(wkdir):
        raise OSError('The working directory : ' + wkdir + 'does not exit!')

    original_dir = os.getcwd()
    os.chdir(wkdir)

    su2f.run_soft('SU2_CFD',config_path,wkdir,nb_proc)
    su2f.run_soft('SU2_SOL',config_path,wkdir,nb_proc)

    os.chdir(original_dir)


def run_SU2_multi(wkdir, nb_proc):
    """Function to run a multiple SU2 claculation.

    Function 'run_SU2_multi' will run in the given working directory SU2
    calculations (SU2_CFD then SU2_SOL). The working directory must have a
    folder sctructure created by 'SU2Config' module.

    Args:
        wkdir (str): Path to the working directory

    """

    if not os.path.exists(wkdir):
        raise OSError('The working directory : ' + wkdir + 'does not exit!')

    original_dir = os.getcwd()
    os.chdir(wkdir)

    # Check if there is some case directory
    case_dir_list = [dir for dir in os.listdir(wkdir) if 'Case' in dir]
    if case_dir_list == []:
        raise OSError('No folder has been found in the working directory: ' + wkdir)

    for dir in sorted(case_dir_list):
        config_dir = os.path.join(wkdir,dir)
        os.chdir(config_dir)

        find_config_cfd = False

        for file in os.listdir(config_dir):
            if file == 'ConfigCFD.cfg':
                if find_config_cfd:
                    raise ValueError('More than one "ConfigCFD.cfg" file in this directory!')
                config_cfd_path = os.path.join(config_dir,file)
                find_config_cfd = True

        if not find_config_cfd:
            raise ValueError('No "ConfigCFD.cfg" file has been found in this directory!')

        su2f.run_soft('SU2_CFD',config_cfd_path,config_dir,nb_proc)
        # su2f.run_soft('SU2_SOL',config_file_path,config_dir,nb_proc)
        # Only useful if you need surface/volume flow file,
        # if not forces_breakdown.dat will be generated by SU2_CFD.

        os.chdir(wkdir)


# TODO: The deformation part should be moved to SU2MeshDef module
def run_SU2_fsi(config_path, wkdir, case, loopNumber):
    """Function to run a SU2 claculation for FSI .

    Function 'run_SU2_fsi' deforms an element of the mesh (e.g. wing) from
    point file 'disp.dat' given by a sctructural model and then runs a SU2
    calculation (SU2_CFD then SU2_SOL) with the given config_path. Finally a
    load file is saved, to be send to the sctructural model.

    Args:
        config_path (str): Path to the configuration file
        wkdir (str): Path to the working directory

    ##########################################################################
    # old version!
    # cfg_def['DV_KIND'] = 'SURFACE_FILE'
    # cfg_def['DV_MARKER'] = 'Wing'
    # cfg_def['DV_FILENAME'] = 'disp.dat' # TODO: Should be a constant or find in CPACS ?
    # # TODO: Do we need that? if yes, find 'WING' in CPACS
    # cfg_def['DV_PARAM'] = ['WING', '0', '0', '1', '0.0', '0.0', '1.0']
    # cfg_def['DV_VALUE'] = 0.01
    ##########################################################################
    """

    if not os.path.exists(wkdir):
        raise OSError('The working directory : ' + wkdir + 'does not exit!')

    original_dir = os.getcwd()
    # Number of iteration desired
    N = config_path['SU2_Niter']
    nb_proc = config_path['SU2_Nproc']
    # Step 1) Check in which iteration the solver is
    wkdir = wkdir + '/CFD'
    # Assembles SU2 configuration file path
    simulationPath = wkdir + case

    if loopNumber == 0:
        # Gets the original Configuration file path and creates the first
        # iteration result folder, changes the program directory to this one'
        originalCFDConfigPath = os.path.join(simulationPath,'ConfigCFD.cfg')

        # Assembles MESH file path
        originalCFDMeshPath = wkdir + '/MESH/'
        meshFileName = os.listdir(originalCFDMeshPath)
        originalCFDMeshPath += meshFileName[0]

        # Creates a folder for the current iteration
        wkdir = os.path.join(simulationPath, str(loopNumber))
        os.makedirs(wkdir)
        os.chdir(wkdir)

        # Writes the configuration file into the current iteration folder and
        # starts the simulation. Modify the configuration file
        cfg_cfd = su2f.read_config(originalCFDConfigPath)
        cfg_cfd['MESH_FILENAME'] = originalCFDMeshPath
        cfg_cfd['SOLUTION_FILENAME'] = 'solution_flow.dat'
        cfg_cfd['SOLUTION_ADJ_FILENAME'] = 'solution_adj.dat'
        cfg_cfd['RESTART_FILENAME'] = 'solution_flow.dat'
        cfg_cfd['RESTART_ADJ_FILENAME'] = 'solution_adj.dat'
        cfg_cfd['INNER_ITER'] = N
        cfg_cfd['RESTART_SOL'] = 'NO'
        currentCFDConfigPath = os.path.join(wkdir,'ConfigCFD.cfg')
        su2f.write_config(currentCFDConfigPath,cfg_cfd)

        # Runs the simulation and computes the results
        su2f.run_soft('SU2_CFD',currentCFDConfigPath,wkdir,nb_proc)
        su2f.run_soft('SU2_SOL',currentCFDConfigPath,wkdir,nb_proc)
        print(wkdir)
        extract_loads(wkdir)

    else:
        # TODO in order to restart the solution, the soltion_flow.vtu of the
        # last aeroelastic step should be put into the next one. Sadly it looks
        # like the solver does not support deformed files. Maybe run the
        # SU2_SOL first could solve the problem.
        
        # Gets the original Configuration file path and creates the first
        # iteration result folder, changes the program directory to this one
        # Assembles SU2 configuration file path
        print(simulationPath)
        originalCFDConfigPath = os.path.join(simulationPath,'ConfigCFD.cfg')
        # originalDEFConfigPath = os.path.join(wkdir,'ConfigDEF.cfg')
        originalSolutionPath = os.path.join(wkdir,str(loopNumber-1))
        # previous working directory
        print(simulationPath)
        prdir = os.path.join(simulationPath,str(loopNumber - 1))
        # current working directory
        print(simulationPath)
        wkdir = os.path.join(simulationPath,str(loopNumber))
        os.makedirs(wkdir)
        os.chdir(wkdir)

        # Writes the configuration file into the current iteration folder and
        # starts the simulation. It looks like the restart solution is not
        # possible with a deformed mesh
        cfg_cfd = su2f.read_config(originalCFDConfigPath)
        # Last iteration solution that is fed into the current iteration.
        cfg_cfd['SOLUTION_FILENAME'] = prdir + '/solution_flow.dat'
        cfg_cfd['SOLUTION_ADJ_FILENAME'] = prdir + '/solution_adj.dat'
        # Solution output that will be read next iteration
        cfg_cfd['RESTART_FILENAME'] = 'solution_flow.dat'
        cfg_cfd['RESTART_ADJ_FILENAME'] = 'solution_adj.dat'
        # Path is correct but there is a core dump. It is really complicated
        # to find where the bug comes from.
        cfg_cfd['RESTART_SOL'] = 'NO'
        cfg_cfd['MESH_FILENAME'] = 'deformed.su2'
        # cfg_cfd['RESTART_ITER'] = N + loopNumber * (N/1)
        cfg_cfd['INNER_ITER'] = N
        currentCFDConfigPath = os.path.join(wkdir,'ConfigCFD.cfg')
        su2f.write_config(currentCFDConfigPath,cfg_cfd)

        # Modification of the config file for SU2_DEF function
        cfg_def = su2f.read_config(originalCFDConfigPath)
        # path = cfg_def['MESH_FILENAME']
        meshPath = os.path.dirname(os.path.dirname(originalCFDConfigPath))
        meshPath = os.path.join(meshPath,'MESH')
        # print(meshPath)
        meshName = os.listdir(meshPath)
        # print(meshName[0])
        cfg_def['MESH_FILENAME'] = os.path.join(meshPath,meshName[0])
        cfg_def['MESH_OUT_FILENAME'] = 'deformed.su2'
        ###################################################
        cfg_def['DV_KIND'] = 'SURFACE_FILE'
        cfg_def['DV_MARKER'] = cfg_def['MARKER_EULER']
        cfg_def['DV_PARAM'] = (1, 0.5)
        cfg_def['DV_VALUE'] = 0.1
        cfg_def['DV_FILENAME'] = prdir + '/disp.dat'
        ##################################################
        cfg_def['MARKER_DEFORM_MESH'] = cfg_def['MARKER_EULER']
        # 'FGMRES','RESTARTED_FGMRES','BCGSTAB'
        cfg_def['DEFORM_LINEAR_SOLVER'] = 'FGMRES'
        cfg_def['DEFORM_LINEAR_SOLVER_PREC'] = 'LU_SGS'
        cfg_def['DEFORM_LINEAR_SOLVER_ITER'] = 1500
        cfg_def['DEFORM_NONLINEAR_ITER'] = 1
        cfg_def['DEFORM_CONSOLE_OUTPUT'] = 'YES'
        cfg_def['DEFORM_LINEAR_SOLVER_ERROR'] = 1E-14
        cfg_def['DEFORM_COEFF'] = 1E6
        # 'INVERSE_VOLUME', 'WALL_DISTANCE', 'CONSTANT_STIFFNESS'
        cfg_def['DEFORM_STIFFNESS_TYPE'] = 'WALL_DISTANCE'
        cfg_def['VISUALIZE_SURFACE_DEF'] = 'YES'
        cfg_def['VISUALIZE_VOLUME_DEF'] = 'YES'
        ###################################################
        cfg_def['CONV_CRITERIA'] = 'CAUCHY'
        cfg_def['CONV_RESIDUAL_MINVAL'] = -8
        cfg_def['CONV_STARTITER'] = 10
        cfg_def['CONV_CAUCHY_ELEMS'] = 100
        cfg_def['CONV_CAUCHY_EPS'] = 1E-6
        ###################################################
        # cfg_def['DEFORM_MESH'] = 'YES'
        ###################################################
        currentDEFConfigPath = os.path.join(wkdir,'ConfigDEF.cfg')
        su2f.write_config(currentDEFConfigPath,cfg_def)

        su2f.run_soft('SU2_DEF',currentDEFConfigPath,wkdir,nb_proc)
        sys.exit()
        su2f.run_soft('SU2_CFD',currentCFDConfigPath,wkdir,nb_proc)
        su2f.run_soft('SU2_SOL',currentCFDConfigPath,wkdir,nb_proc)
        extract_loads(wkdir)
    os.chdir(original_dir)

#==============================================================================
#    MAIN
#==============================================================================


if __name__ == '__main__':

    log.info('----- Start of ' + os.path.basename(__file__) + ' -----')

    cpacs_path = os.path.join(MODULE_DIR,'ToolInput','ToolInput.xml')
    cpacs_out_path = os.path.join(MODULE_DIR,'ToolOutput','ToolOutput.xml')

    tixi = cpsf.open_tixi(cpacs_path)

    # Get number of proc to use
    nb_proc = cpsf.get_value_or_default(tixi,SU2_XPATH+'/settings/nbProc',1)

    if len(sys.argv)>1:
        if sys.argv[1] == '-c':
            wkdir = ceaf.get_wkdir_or_create_new(tixi)
            generate_su2_config(cpacs_path,cpacs_out_path,wkdir)
        elif sys.argv[1] == '-s':
            wkdir = os.path.join(MODULE_DIR,sys.argv[2])
            config_path = os.path.join(wkdir,'ConfigCFD.cfg') # temporary
            run_SU2_single(config_path,wkdir,nb_proc)
        elif sys.argv[1] == '-m':
            wkdir = os.path.join(MODULE_DIR,sys.argv[2])
            run_SU2_multi(wkdir,nb_proc)
        elif sys.argv[1] == '-f':
            wkdir = os.path.join(MODULE_DIR,sys.argv[2])
            config_path = os.path.join(wkdir,'ConfigCFD.cfg')   # temporary
            run_SU2_fsi(config_path,wkdir,nb_proc)
        elif sys.argv[1] == '-r':
            wkdir = os.path.join(MODULE_DIR,sys.argv[2])
            get_su2_results(cpacs_path,cpacs_out_path,wkdir)
        else:
            print('This arugment is not a valid option!')
    else: # if no argument given
        wkdir = ceaf.get_wkdir_or_create_new(tixi)
        generate_su2_config(cpacs_path,cpacs_out_path,wkdir)
        run_SU2_multi(wkdir,nb_proc)
        get_su2_results(cpacs_path,cpacs_out_path,wkdir)

    # TODO: cpacs_out_path for 'create_config' should be a temp file, now it's erase by 'get_su2get_su2_results'

    log.info('----- End of ' + os.path.basename(__file__) + ' -----')



# TODO: try to use subprocess instead of os.system, how to deal with log file...?
# import subprocess
# p = subprocess.Popen(command_line, stdout=subprocess.PIPE)
# log_lines = p.communicate()[0]
# logfile = open(logfile_path, 'w')
# logfile.writelines(log_lines)
# logfile.close()
